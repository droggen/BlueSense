<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>sd.c</title><link rel="stylesheet" type="text/css" href="../styles/main.css"><script type="text/javascript" src="../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.0 (Development Release 08-22-2015) -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->

<body onload="NDLoader.OnLoad('Content');" class="NDPage NDContentPage">

<a name="sd"></a><a name="Topic93"></a><div class="CTopic TFile LC first">
 <div class="CTitle">sd</div>
 <div class="CBody"><p>SD card functions.</p><p>This provides low-level communication with SDHC cards (to check: compatibility with SDXC).</p><p>This library requires cards compatible with the Physical Spec version 2.00. This rules out some standard capacity SD cards and MMC cards.</p><p>As this library uses the Physical Spec Version 2.0 all card read/write operations must be done on entire sectors (512-bytes) and the address of read and write operations are given in sectors.</p><p><b>General functions</b></p><ul><li><p>sd_init:							Initialise the SD card and returns card CID, CSD and capacity.</p></li><li><p>sd_print_csd:						Prints the CSD fields to a stream.</p></li><li><p>sd_print_cid:						Prints the CID fields to a stream.</p></li><li><p>sd_print_ocr						Prints the OCR fields to a stream.</p></li></ul><p><b>Individual block read/write</b></p><p>SD card sectors (512-bytes blocks) can be read and written with:</p><ul><li><p>sd_block_write: 					Writes a sector of data at sector addr.</p></li><li><p>sd_block_read:					Reads a sector of data from sector addr.</p></li></ul><p>The address is the absolute sector number on the SD card.</p><p><b>Streaming writes</b></p><p>Stream write functions allow to initiate (open) a &quot;streaming write&quot; operation to the memory card, and write one or more data blocks. Internally, SD-card &quot;multiblock writes&quot; are used to speed-up writes (i.e. it avoids group erases after single sector writes).</p><p>To perform a streaming write:</p><p>1. Open the block to write into with sd_stream_open 2. Provide the block data with any number of calls to sd_stream_write 3. Close the block with sd_stream_close</p><p>sd_stream_write returns whenever a complete data block is written to the card, so that the application can decide e.g. to update a FAT (sd_stream_close must be called first to terminate the ongoing multiple block write if a e.g. a FAT were to be updated). It is the application's responsibility to call sd_stream_write multiple times if needed until all the data has been written.</p><p>The following functions are availablefor streaming writes:</p><ul><li><p>sd_stream_open:				Start a stream write at the specified address (used both for caching and non-caching streaming writes).</p></li><li><p>sd_stream_write:				Writes data in streaming multiblock write</p></li><li><p>sd_stream_close:				Terminates a streaming write.</p></li></ul><p><b>Streaming writes with caching</b></p><p>Streaming write with caching allows to reach higher performance than streaming write without.</p><p>To perform a streaming write with caching:</p><p>1. Open the block to write into with sd_stream_open 2. Provide the block data with any number of calls to sd_streamcache_write 3. Close the block with sd_streamcache_close</p><p>sd_streamcache_write returns only if the entire data has been written to the card or to the cache, or if there is an error.&nbsp; Note that this behavior is different from sd_stream_write which returns when a block is completed or all the data is written.</p><ul><li><p>sd_stream_open:				Start a stream write at the specified address (used both for caching and non-caching streaming writes).</p></li><li><p>sd_streamcache_write:			Writes data in streaming multiblock write with caching.</p></li><li><p>sd_streamcache_close			Finishes a multiblock write with caching.</p></li></ul><p><b>Dependencies</b></p><ul><li><p>spi</p></li><li><p>Card on SPI interface: this library assumes the card is interfaced on the SPI interface. The SPI interface must be initialised before using this library.</p></li></ul><p><b>Usage in interrupts</b> Not suitable for use in interrupts.</p><p><b>Possible improvements</b> Reduce or remove delay prior to command</p></div>
</div>

<a name="Functions"></a><a name="Topic94"></a><div class="CTopic TGroup LC">
 <div class="CTitle">Functions</div>
</div>

<a name="sd_init"></a><a name="Topic95"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sd_init</div>
 <div id="NDPrototype95" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> sd_init(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td class="PType">CID&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">cid,</td></tr><tr><td class="first"></td><td class="PType">CSD&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">csd,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">capacity</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Initialise the SD card and returns card CID, CSD and capacity.</p><p>This function supports SDHC cards (to check: SDXC). It does not support version 1 SD cards nor MMC cards.</p><p>This function requires the SPI interface to have been initialised.</p><p>The initialisation procedure is as follows: - Issue clock pulses - Issue CMD0 with cs - Issue CMD8 (SEND_IF_COND) (required to be compliant with Physical Spec Version 2.00) and check echo back and voltage range - [Issue CMD58 (Read OCR) and check voltage range] This is unnecessary as CMD58 is issued after ACMD41 again for extended info.&nbsp; - Issue ACMD41 - Issue CMD58 (Read OCR) and check voltage range - Read CSD - Read CID</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">cid<div class="CDLParameterType">CID*</div></td><td class="CDLDefinition"><p>Pointer to receive card CID</p></td></tr><tr><td class="CDLEntry">csd<div class="CDLParameterType">CSD*</div></td><td class="CDLDefinition"><p>Pointer to receive card CSD</p></td></tr><tr><td class="CDLEntry">capacity<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span>*</div></td><td class="CDLDefinition"><p>Pointer to receive card capacity in sectors</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="sd_block_read"></a><a name="Topic80"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sd_block_read</div>
 <div id="NDPrototype80" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> sd_block_read(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td></td><td class="PName last">addr,</td></tr><tr><td class="first"></td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">buffer</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Reads a sector of data from sector addr.</p><p>The block size is fixed at 512 bytes, i.e. one sector.&nbsp; Uses internally the single block write function.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">addr<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span></div></td><td class="CDLDefinition"><p>Address in sector (0=first sector, 1=second sector, ...)</p></td></tr><tr><td class="CDLEntry">buffer<div class="CDLParameterType"><span class="SHKeyword">char</span>*</div></td><td class="CDLDefinition"><p>Buffer of 512 bytes which receives the data</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">nonzero</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="sd_block_write"></a><a name="Topic81"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sd_block_write</div>
 <div id="NDPrototype81" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> sd_block_write(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td></td><td class="PName last">addr,</td></tr><tr><td class="first"></td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">buffer</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Writes a sector of data at sector addr.</p><p>The block size is fixed at 512 bytes, i.e. one sector.&nbsp; Uses internally the single block write function.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">addr<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span></div></td><td class="CDLDefinition"><p>Address in sector (0=first sector, 1=second sector, ...)</p></td></tr><tr><td class="CDLEntry">buffer<div class="CDLParameterType"><span class="SHKeyword">char</span>*</div></td><td class="CDLDefinition"><p>Buffer of 512 bytes of data to write</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">nonzero</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="sd_stream_open"></a><a name="Topic98"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sd_stream_open</div>
 <div id="NDPrototype98" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sd_stream_open(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td class="PName last">addr</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Start a stream write at the specified address (used both for caching and non-caching streaming writes).</p><p>This function initialises the state machine internally used for streaming writes.&nbsp; Internally, multiblock transfers to the SD card are used.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">addr<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span></div></td><td class="CDLDefinition"><p>Write start address in sectors</p></td></tr></table></div>
</div>

<a name="sd_stream_write"></a><a name="Topic84"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sd_stream_write</div>
 <div id="NDPrototype84" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> sd_stream_write(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">buffer,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td></td><td class="PName last">size,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">currentsect</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Writes data in streaming multiblock write</p><p>This function does not use any cache to hide the card write time and thus speedup writes.</p><p>This function returns whenever a complete data block is written to the card, so that the application can decide e.g. to update a FAT (sd_stream_close must be called first to terminate the ongoing multiple block write if a e.g. a FAT were to be updated).&nbsp; It is the application's responsibility&nbsp; to call sd_stream_write multiple times if needed until all the data has been written.</p><p>In the current implementation it is not possible to distinguish from the return value whether the function returns because a 512-bytes block is completed or because all the user-specified bytes are written. The variable currentaddr may be used for this or an auxiliary user counter must be used for this.</p><p>In case of error in sd_stream_write the following occurs: - the multiple block write is terminated (application needs not call sd_stream_close - this is internally done) - the stream is in closed state - attempt to open it will be done the next time sd_stream_write is called.&nbsp; - Either the block where the write error is skipped (no valid data within that block) and writes continues from the next one, or the same block is reopened if the error occurred during opening the block</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">buffer<div class="CDLParameterType"><span class="SHKeyword">char</span>*</div></td><td class="CDLDefinition"><p>Buffer of data to write</p></td></tr><tr><td class="CDLEntry">size<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">short</span></div></td><td class="CDLDefinition"><p>Number of bytes to write</p></td></tr><tr><td class="CDLEntry">currentsect<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span>*</div></td><td class="CDLDefinition"><p>Optionally a pointer to a variable holding the address (in sectors) of the block currently being used to store the data.&nbsp; If 0, the address will not be provided</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">other</td><td class="CDLDefinition"><p>Failure</p></td></tr></table></div>
</div>

<a name="sd_streamcache_write"></a><a name="Topic92"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sd_streamcache_write</div>
 <div id="NDPrototype92" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> sd_streamcache_write(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">buffer,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td></td><td class="PName last">size,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">currentsect</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Writes data in streaming multiblock write with caching.</p><p>Rationale for caching: after completing a block the card needs some time to be ready for a new block. This time is generally short but occasionnally may be longer when block reordering occurs.&nbsp; If sd_streamcache_write is called while the card is still busy from a prior write the data is moved into the cache and the function returns immediately.&nbsp; If the cache has no space for the data then the function will block until the cards is ready and will open a new block and write directly the data to the card.&nbsp; Upon subsequent writes, or calling sd_streamcache_close, the cache content is written to the card.</p><p>This function uses the cache buffer _sdbuffer and ensures it does not grow above SD_CACHE_SIZE.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">buffer<div class="CDLParameterType"><span class="SHKeyword">char</span>*</div></td><td class="CDLDefinition"><p>Buffer of data to write</p></td></tr><tr><td class="CDLEntry">size<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">short</span></div></td><td class="CDLDefinition"><p>Number of bytes to write. Use size=0 to flush the</p></td></tr><tr><td class="CDLEntry">currentsect<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span>*</div></td><td class="CDLDefinition"><p>Optionally a pointer to a variable holding the address (in sectors) of the block currently being used to store the data.&nbsp; If 0, the address will not be provided</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">other</td><td class="CDLDefinition"><p>Failure</p></td></tr></table></div>
</div>

<a name="sd_print_csd"></a><a name="Topic101"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sd_print_csd</div>
 <div id="NDPrototype101" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sd_print_csd(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">FILE&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">f,</td></tr><tr><td class="PType first">CSD&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">csd</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Prints the CSD fields to a stream.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">f<div class="CDLParameterType">FILE*</div></td><td class="CDLDefinition"><p>Stream on which to print</p></td></tr><tr><td class="CDLEntry">csd<div class="CDLParameterType">CSD*</div></td><td class="CDLDefinition"><p>Pointer to CSD</p></td></tr></table></div>
</div>

<a name="sd_print_cid"></a><a name="Topic102"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sd_print_cid</div>
 <div id="NDPrototype102" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sd_print_cid(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">FILE&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">f,</td></tr><tr><td class="PType first">CID&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">cid</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Prints the CID fields to a stream.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">f<div class="CDLParameterType">FILE*</div></td><td class="CDLDefinition"><p>Stream on which to print</p></td></tr><tr><td class="CDLEntry">cid<div class="CDLParameterType">CID*</div></td><td class="CDLDefinition"><p>Pointer to CID</p></td></tr></table></div>
</div>

<a name="sd_print_ocr"></a><a name="Topic103"></a><div class="CTopic TFunction LC last">
 <div class="CTitle">sd_print_ocr</div>
 <div id="NDPrototype103" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sd_print_ocr(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">FILE&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">f,</td></tr><tr><td class="PType first">OCR&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">ocr</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Prints the OCR fields to a stream.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">f<div class="CDLParameterType">FILE*</div></td><td class="CDLDefinition"><p>Stream on which to print</p></td></tr><tr><td class="CDLEntry">cid</td><td class="CDLDefinition"><p>Pointer to OCR</p></td></tr></table></div>
</div>

</body></html>