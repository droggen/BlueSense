<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>ufat.c</title><link rel="stylesheet" type="text/css" href="../styles/main.css"><script type="text/javascript" src="../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.0 (Development Release 08-22-2015) -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->

<body onload="NDLoader.OnLoad('Content');" class="NDPage NDContentPage">

<a name="ufat"></a><a name="Topic21"></a><div class="CTopic TFile LC first">
 <div class="CTitle">ufat</div>
 <div class="CBody"><p>uFAT filesystem.</p><p>This provides a minimalistic uFAT filesystem, compatible with FAT32, optimised for streaming writes and which can be read seamlessly from a card reader.</p><p>This library assumes a carefully laid out filesystem which has been designed to optimise streaming write speed and to minimise code usage.&nbsp; The tradeoff of this optimisation are the following:</p><ul><li><p>Only file write is possible</p></li><li><p>Only one file can be written to at any time</p></li><li><p>Seek/append operations are not implemented</p></li><li><p>The maximum number of files in the file system is limited to 14</p></li><li><p>Only legacy 8.3 file names are supported</p></li><li><p>Folders are not supported</p></li><li><p>File names are pre-defined and cannot be changed</p></li><li><p>The maximum size of files is the same for all files and pre-defined during formatting based on the total card capacity (i.e. MaxFileSize=CardCapacity/NumFiles)</p></li><li><p>The filesystem must only be formatted by this library; formatting on a computer will not result in a card that this library can use</p></li><li><p>Any file write, file rename or file move operation performed on a computer will lead to errors or data loss the next time that this library attempts to write to the card.&nbsp; There is no issue if the card is only used on a computer after such an operation. However, if the card were used again with this library a formatting would be required.</p></li><li><p>The first sector of the ROOT entry contains 16 directory entries. The entry 0 is the volume ID; entries 1 to n are the log files, entry n+1 to 14 are dummy files marked as erased to prevent the OS from modifying this; entry 15 is uFAT metadata, stored as a file marked as erased. Upon checking the filesystem a checksum is run on this metadata to ensure no other operating system has tampered with them.</p></li><li><p>During formatting all the clusters that the log files will use when having the maximum size are marked as used (cluster linked, i.e. nonzero value).&nbsp; This prevents another OS from using clusters that uFAT needs as the log file grows.&nbsp; Consequently the disk free space reported by a conventional OS will be constant and tiny (in the MB range), regardless of the size of the uFAT files.</p></li></ul><p>The filesystem is implemented with the following characteristics:</p><ul><li><p>There is only one FAT; uFAT does not create the secondary FAT commonly created by traditional OSes</p></li><li><p>The size of the sectors is 512 bytes</p></li><li><p>The size of the clusters is 64 sectors (64*512=32KB)</p></li><li><p>The ROOT directory for the uFAT files is stored in exactly one sector; this limits the number of ROOT entries to a maximum of 16, and therefore the number of files to 14 (volumeID+14 log files+metadata stored as a fake file).</p></li><li><p>The first cluster of each files is allocated on a cluster that is the first cluster of a sector of the FAT (i.e. start location is a multiple of 128 clusters). This simplifies the FAT update.</p></li><li><p>Upon formatting, files are pre-allocated on consecutive clusters which avoid fragmentation. The FAT is programmed accordingly. As data is written to the file, only the file length needs to be updated. This avoids slow FAT updates.</p></li><li><p>The file size is updated only upon closing a file. This speeds-up streaming writes at the expense of lower reliability if the platform crashes before a file is closed.</p></li></ul><p>It is recommended to ensure another operating system never writes to a uFAT formatted sd-card.&nbsp; Windows generally creates a &quot;System Volume Information&quot; and associated files when an SD-card is plugged in, without user intervention.&nbsp; uFAT tweaks the FAT to minimise the risk of Windows writing to a location that uFAT would use (e.g. it marks the first 16 ROOT entries as used or deleted files; it marks all clusters that could be used by log files as used/linked).&nbsp; This strategy appears to work but has not been extensively tested. An alternative is to prevent any OS write to the disk.&nbsp; The following link indicates how to prevent Windows creating such folders/files on a removable media: <a href="http://www.thewindowsclub.com/prevent-system-volume-information-folder-usb" target="_top">http://&#8203;www&#8203;.thewindowsclub&#8203;.com&#8203;/prevent-system-volume-information-f&#8203;older-usb</a></p><p><b>Public functions</b></p><ul><li><p>ufat_format:						Format a card with the uFAT filesystem. The filesystem is ready to be used immediately afterwards.</p></li><li><p>ufat_init:						Initialise the uFAT filesystem including low-level card initialisation and filesystem check.</p></li><li><p>ufat_available:					Indicates whether the system successfully detected a disk with uFAT.</p></li><li><p>ufat_log_open:					Opens the indicated log file for write operations using fprintf, fputc, fputbuf, etc</p></li><li><p>ufat_log_close:					Close the previously opened log file</p></li><li><p>ufat_log_test:					Test writing data to a log file</p></li><li><p>ufat_log_getmaxsize: 				Returns the maximum size of files in the given filesystem.</p></li><li><p>ufat_log_getsize: 				Returns the size of the currently open file.</p></li><li><p>ufat_log_getnumlogs:				Returns the number of logs available</p></li></ul><p><b>Dependencies</b></p><ul><li><p>spi</p></li><li><p>Card on SPI interface: this library assumes the card is interfaced on the SPI interface. The SPI interface must be initialised before using this library.</p></li></ul><p><b>Usage in interrupts</b></p><p>Not suitable for use in interrupts.</p><p><b>Possible improvements</b></p><ul><li><p>The card is formatted with type 0x0a (FAT32). Some documentation indicate that this limits partitions to less than 2GB. While no issues have been encountered using type 0x0C could be tested.</p></li><li><p>Some SD cards are formatted without a partition table but start straight with a boot sector, as in old diskettes.&nbsp; Formatting the card in this way would reduce slightly the code size of this library.</p></li><li><p>When writing a log and updating the FAT we assume that FAT sectors contain only a cluster chain related to uFAT and all the unused clusters are reset to 0. If another operating system would use these free clusters, writing a log would corrupt these files.</p></li><li><p>Further robustness testing is required if another operating system writes to the disk to check for possible corruption.</p></li></ul></div>
</div>

<a name="Functions"></a><a name="Topic49"></a><div class="CTopic TGroup LC">
 <div class="CTitle">Functions</div>
</div>

<a name="ufat_format"></a><a name="Topic50"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ufat_format</div>
 <div id="NDPrototype50" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> ufat_format(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">numlogfile</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Format a card with the uFAT filesystem. The filesystem is ready to be used immediately afterwards.</p><p>Performs a low-level initialisation of the SD card, formats the card, and initialises the internal data structures.</p><p>After formatting there is no need to call ufat_init to initialise the filesystem.</p><p>This function assumes that the SPI peripheral has been initialised.&nbsp; It performs low-level SD-card initialisation followed by formatting.&nbsp; It attemps to strike a balance between erasing all the sectors of the card, which would be too slow on an avr (with a streaming block write this could takes ~23 hours at ~200KB/s with a 16GB card), and erasing a minimum set.</p><p>The sectors corresponding to 3 clusters of the ROOT (3*64 sectors) are cleared, as _ufat_format_fat_root initialises 3 clusters for the ROOT (note: this 3-cluster assumption is based on reverse engineering of a computer formatted file system and not fully analysed).&nbsp; The sectors of the FAT1 and FAT2 (i.e. all sectors between the beginning of FAT1 and the start of the cluster area) are cleared.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">numlogfile<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Number of log files to create (between 1 and _UFAT_NUMLOGENTRY).</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="ufat_init"></a><a name="Topic51"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ufat_init</div>
 <div id="NDPrototype51" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> ufat_init(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Initialise the uFAT filesystem including low-level card initialisation and filesystem check.&nbsp; The filesystem is ready to be used immediately afterwards.</p><p>This function must be called prior to using the uFAT system.</p><p>This function assumes that the SPI peripheral has been initialised.&nbsp; It performs low-level SD-card initialisation followed by filesystem initialisation.</p><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="ufat_available"></a><a name="Topic52"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ufat_available</div>
 <div id="NDPrototype52" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> ufat_available(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Indicates whether the system successfully detected a disk with uFAT.</p><p>This function must only be called after a ufat_init or ufat_format call.</p><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="ufat_log_open"></a><a name="Topic53"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ufat_log_open</div>
 <div id="NDPrototype53" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters">FILE *ufat_log_open(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">n</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Opens the indicated log file for write operations using fprintf, fputc, fputbuf, etc.</p><p>Only one log file can be open at any time.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">n<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Number of the log file to open; the maximum number available depends on how the card was formatted.</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Error</p></td></tr><tr><td class="CDLEntry">nonzero</td><td class="CDLDefinition"><p>FILE* for write operations</p></td></tr></table></div>
</div>

<a name="ufat_log_close"></a><a name="Topic54"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ufat_log_close</div>
 <div id="NDPrototype54" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> ufat_log_close(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Close the previously opened log file</p><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>always</p></td></tr></table></div>
</div>

<a name="ufat_log_test"></a><a name="Topic55"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ufat_log_test</div>
 <div id="NDPrototype55" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> ufat_log_test(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">lognum,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td class="PName last">size,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">ch,</td></tr><tr><td class="first"></td><td class="PType"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PName last">bsize</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Test writing data to a log file.&nbsp; The data is written in blocks using the putbuf function; bsize indicate the size of the blocks.&nbsp; In practice floor(size/bsize)*bsize bytes are written to the file.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">lognum<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Log number to write to</p></td></tr><tr><td class="CDLEntry">size<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span></div></td><td class="CDLDefinition"><p>Number of bytes to write</p></td></tr><tr><td class="CDLEntry">ch<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Byte to write</p></td></tr><tr><td class="CDLEntry">bsize<div class="CDLParameterType"><span class="SHKeyword">unsigned</span></div></td><td class="CDLDefinition"><p>Size of the blocks written to the file, maximum 512.</p></td></tr></table></div>
</div>

<a name="ufat_log_getmaxsize"></a><a name="Topic56"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ufat_log_getmaxsize</div>
 <div id="NDPrototype56" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span> ufat_log_getmaxsize(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Returns the maximum size of files in the given filesystem.</p><p>This function requires the filesystem to be initialised.</p><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Error</p></td></tr><tr><td class="CDLEntry">nonzero</td><td class="CDLDefinition"><p>Maximum size of the files</p></td></tr></table></div>
</div>

<a name="ufat_log_getsize"></a><a name="Topic57"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ufat_log_getsize</div>
 <div id="NDPrototype57" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span> ufat_log_getsize(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Returns the size of the currently open file.</p><p>This function requires the filesystem to be initialised and a log file to be open to return a valid result.</p><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Error</p></td></tr><tr><td class="CDLEntry">nonzero</td><td class="CDLDefinition"><p>Maximum size of the files</p></td></tr></table></div>
</div>

<a name="ufat_log_getnumlogs"></a><a name="Topic22"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ufat_log_getnumlogs</div>
 <div id="NDPrototype22" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> ufat_log_getnumlogs(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Returns the number of logs available.</p><p>If the filesystem is not to be initialised and a log file to be open to return a valid result.</p><div class="CHeading">Returns</div><p>Number of logs available, or 0 if the filesystem is not available.</p></div>
</div>

<a name="_ufat_init_sd"></a><a name="Topic58"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_ufat_init_sd</div>
 <div id="NDPrototype58" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> _ufat_init_sd(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Initialise the SD-card subsystem and check that the SD card is suitable.</p><p>Updates the global variable _fsinfo with the uFAT state: _fsinfo.card_available according to card availability _fsinfo.fs_available to false _fsinfo.card_capacity_sector tp the card capacity</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">capacity_sector</td><td class="CDLDefinition"><p>Pointer to hold the card capacity of the card in number of sectors</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="_ufat_init_fs"></a><a name="Topic59"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_ufat_init_fs</div>
 <div id="NDPrototype59" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> _ufat_init_fs(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Initialise the uFAT filesystem data structures from a uFAT-formatted card.</p><p>Must be called after _ufat_init_sd</p><p>Assumes a card formatted with uFAT. Reads the MBR, boot sector, and root entry and initialise the FSINFO structure with data related to the card.</p><div class="CHeading">Updates</div><p>_fsinfo.fs_available _fsinfo.logstartcluster _fsinfo.logsizecluster _fsinfo.logsizebytes _fsinfo.lognum</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">capacity_sector</td><td class="CDLDefinition"><p>Capacity of the card in number of sectors</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="_ufat_getpart"></a><a name="Topic23"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_ufat_getpart</div>
 <div id="NDPrototype23" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> _ufat_getpart(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">block,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td></td><td class="PName last">pn,</td></tr><tr><td class="first"></td><td class="PType">PARTITION&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">p</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Copies the partition entry from a buffer comprising the master boot record into a PARTITION structure.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">block<div class="CDLParameterType"><span class="SHKeyword">char</span>*</div></td><td class="CDLDefinition"><p>Pointer to a buffer holding the master boot record</p></td></tr><tr><td class="CDLEntry">pn<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Partition number, from 0 to 3</p></td></tr><tr><td class="CDLEntry">p<div class="CDLParameterType">PARTITION*</div></td><td class="CDLDefinition"><p>Pointer to a PARTITION structure that will receive the partition entry</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="_ufat_format_mbr_boot"></a><a name="Topic61"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_ufat_format_mbr_boot</div>
 <div id="NDPrototype61" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> _ufat_format_mbr_boot(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Performs formatting of the card MBR and the BOOT sector of partition 0.</p><p>This is used internally by ufat_format.&nbsp; This function initialises the fsinfo structure.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">capacity_sector</td><td class="CDLDefinition"><p>Card capacity in sectors</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="_ufat_write_root"></a><a name="Topic62"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_ufat_write_root</div>
 <div id="NDPrototype62" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> _ufat_write_root(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">numlogfile</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Creates the root entries with the available files and metadata.</p><p>This is used internally by ufat_format and ufat_log_close.&nbsp; The variables _logentries and _fsinfo must be initialised before calling this function.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">numlogfile<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Number of log files</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="_ufat_format_fat_log"></a><a name="Topic63"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_ufat_format_fat_log</div>
 <div id="NDPrototype63" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> _ufat_format_fat_log(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">i,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td class="PName last">fat_sector</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Creates the FAT cluster chain for one log entry.&nbsp; Assumes the all fat sectors comprise only clusters from a single file (assumption respected by having file sizes multiples of 128 clusters)</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">i<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Number of log files</p></td></tr><tr><td class="CDLEntry">fat_sector<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span></div></td><td class="CDLDefinition"><p>Location of the FAT</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="_ufat_format_fat_root"></a><a name="Topic64"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_ufat_format_fat_root</div>
 <div id="NDPrototype64" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> _ufat_format_fat_root(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td class="PName last">fat_sector</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Creates the FAT cluster chain for the ROOT directory.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">fat_sector<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span></div></td><td class="CDLDefinition"><p>Location of the FAT</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="_ufat_bs2keyinfo"></a><a name="Topic65"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_ufat_bs2keyinfo</div>
 <div id="NDPrototype65" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> _ufat_bs2keyinfo(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">BOOTSECT_FAT32&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">bs,</td></tr><tr><td class="PType first">FSINFO&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">fi</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Summarize key info from boot sector in an _fsinfo structure</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">bs<div class="CDLParameterType">BOOTSECT_FAT32*</div></td><td class="CDLDefinition"><p>Boot sector structure</p></td></tr><tr><td class="CDLEntry">fi<div class="CDLParameterType">FSINFO*</div></td><td class="CDLDefinition"><p>_fsinfo structure containing the key info about the filesystem</p></td></tr></table></div>
</div>

<a name="_ufat_mbr_boot_read"></a><a name="Topic66"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_ufat_mbr_boot_read</div>
 <div id="NDPrototype66" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> _ufat_mbr_boot_read(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Initialises the internal data structure _fsinfo to access the FAT by reading the card MBR and boot sector.</p><p>Reads the MBR and first partition BOOT sector, performs sanity checking, and extracts the key parameters of the filesystem in the global _fsinfo structure.</p><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="ufat_print_boot"></a><a name="Topic67"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ufat_print_boot</div>
 <div id="NDPrototype67" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> ufat_print_boot(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">FILE&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">f,</td></tr><tr><td class="PType first">BOOTSECT_FAT32&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">bs</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Print boot sector information</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">f<div class="CDLParameterType">FILE*</div></td><td class="CDLDefinition"><p>File on which to print information</p></td></tr><tr><td class="CDLEntry">bs<div class="CDLParameterType">BOOTSECT_FAT32*</div></td><td class="CDLDefinition"><p>Boot sector structure</p></td></tr></table></div>
</div>

<a name="ufat_print_fsinfo"></a><a name="Topic68"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ufat_print_fsinfo</div>
 <div id="NDPrototype68" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> ufat_print_fsinfo(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">FILE&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">f,</td></tr><tr><td class="PType first">FSINFO&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">fi</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Print uFAT key informations</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">f<div class="CDLParameterType">FILE*</div></td><td class="CDLDefinition"><p>File on which to print information</p></td></tr><tr><td class="CDLEntry">bs</td><td class="CDLDefinition"><p>Boot sector structure</p></td></tr></table></div>
</div>

<a name="_ufat_log_fputbuf"></a><a name="Topic26"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_ufat_log_fputbuf</div>
 <div id="NDPrototype26" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> _ufat_log_fputbuf(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">buffer,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td></td><td class="PName last">size</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Internally used to write data to logs when fputbuf is called.&nbsp; Do not call directly.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">buffer<div class="CDLParameterType"><span class="SHKeyword">char</span>*</div></td><td class="CDLDefinition"><p>Buffer containing the data</p></td></tr><tr><td class="CDLEntry">size<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Size of buffer Returns:</p></td></tr><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">EOF</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

<a name="_ufat_log_fputchar"></a><a name="Topic119"></a><div class="CTopic TFunction LC last">
 <div class="CTitle">_ufat_log_fputchar</div>
 <div id="NDPrototype119" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">int</span> _ufat_log_fputchar(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first"><span class="SHKeyword">char</span>&nbsp;</td><td></td><td class="PName last">c,</td></tr><tr><td class="PType first">FILE&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">f</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Internally used to write one byte to logs when fprintf/fputs/fpuc are called</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">c<div class="CDLParameterType"><span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Character to write</p></td></tr><tr><td class="CDLEntry">f<div class="CDLParameterType">FILE*</div></td><td class="CDLDefinition"><p>File stream Returns:</p></td></tr><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">EOF</td><td class="CDLDefinition"><p>Error</p></td></tr></table></div>
</div>

</body></html>