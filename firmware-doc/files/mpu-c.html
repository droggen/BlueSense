<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>mpu.c</title><link rel="stylesheet" type="text/css" href="../styles/main.css"><script type="text/javascript" src="../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.0 (Development Release 08-22-2015) -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->

<body onload="NDLoader.OnLoad('Content');" class="NDPage NDContentPage">

<a name="mpu"></a><a name="Topic291"></a><div class="CTopic TFile LC first">
 <div class="CTitle">mpu</div>
 <div class="CBody"><p>MPU9250 functions</p><p>The key functions are:</p><ul><li><p>mpu_init:					initialise the mpu</p></li><li><p>mpu_config_motionmode:	selects the acquisition mode (which sensors are acquired and the sample rate) and whether &quot;automatic read&quot; into a memory buffer is performed.</p></li><li><p>mpu_get_a:				blocking read of acceleration when not in automatic read (can also be used in automatic read).</p></li><li><p>mpu_get_g:				blocking read of gyroscope when not in automatic read (can also be used in automatic read).</p></li><li><p>mpu_get_agt:				blocking read of acceleration, gyroscope and temperature when not in automatic read (can also be used in automatic read).</p></li><li><p>mpu_get_agmt:				blocking read of acceleration, acceleration, magnetic field and temperature when not in automatic read (can also be used in automatic read).</p></li></ul><p><b>Automatic read</b> The recommended mode of operation is to use the &quot;automatic read&quot; in mpu_config_motionmode. In this mode, the MPU data is read at the indicated rate in background (interrupt routine) and made available in memory buffers.&nbsp; In automatic read mode, the following functions and variables are used to access the data in the buffer:</p><ul><li><p>mpu_data_level:			Function indicating how many samples are in the buffer</p></li><li><p>mpu_data_getnext_raw:		Returns the next data in the buffer (when automatic read is active).</p></li><li><p>mpu_data_getnext:			Returns the next raw and geometry data (when automatic read is active).</p></li></ul><p>In non automatic read, the functions mpu_get_a, mpu_get_g, mpu_get_agt or mpu_get_agmt must be used to acquire the MPU data. These functions can also be called in automatic read, however this is suboptimal and increases CPU load as the data would be acquired in the interrupt routine and 	through this function call.</p><p><b>Statistics</b> The following counters are available to monitor the interrupt-driven automatic read. These counters are cleared upon calling mpu_config_motionmode with a new acquisition mode:</p><ul><li><p>mpu_cnt_int:				counts how often the MPU isr has been triggered</p></li><li><p>mpu_cnt_sample_tot:		counts how many samples occurred, independently of whether successful or not (this is equal or lower than mpu_cnt_int due to possible software downsampling)</p></li><li><p>mpu_cnt_sample_succcess:	counts how many samples were acquired and successfully stored in the buffer; mpu_cnt_sample_succcess-mpu_cnt_sample_tot indicates the number of errors that occurred</p></li><li><p>mpu_cnt_sample_errbusy:	counts how many samples were skipped because the interface was busy (e.g. from an ongoing transfer)</p></li><li><p>mpu_cnt_sample_errfull: 	counts how many samples were skipped because the buffer was full</p></li></ul><p><b>Units</b> The variable mpu_gtorps can be used to convert the gyroscope readings to radians per second. This variable is updated when mpu_setgyroscale is called.&nbsp; Depending on the compiler it is a fixed-point (_Accum) or float variable. Convert the gyroscope reading to radians per second as follows:</p><p>_Accum gx_rps = mpu_data_gx[mpu_data_rdptr] * mpu_gtorps; or float gx_rps = mpu_data_gx[mpu_data_rdptr] * mpu_gtorps;</p><p>Gyroscope sensitivity: full scale 250:			131.072LSB/dps full scale 500:			65.536LSB/dps full scale 1000:		32.768LSB/dps full scale 2000:		16.384LSB/dps</p><p><b>Magnetometer</b></p><table class="CDefinitionList"><tr><td class="CDLEntry">Functions to handle the magnetometer</td><td class="CDLDefinition"><p>prefixed by mpu_mag_... - can only be used when the MPU is configured in a mode where the magnetic field sensor is turned on; otherwise the function time-out due to the magnetic field sensor being inaccessible via the internal I2C interface.</p></td></tr></table><p><b>Interrupt Service Routine (ISR)</b></p><p>The function mpu_isr must be called on the <b>falling</b> edge of the MPU interrupt pin.&nbsp; See next section for the rationale for using the falling edge.</p><p><b>Interrupt Service Routine (ISR) Internal notes</b></p><p>The MPU can be configured with register 55d (MPU_R_INTERRUPTPIN): - Logic low or logic high - Open-drain or push-pull - Level held until cleared or generate a 50uS pulse - Interrupt cleared after any read operation or after reading the INT_STATUS register</p><p>Here &quot;logic high&quot;, &quot;push pull&quot; and &quot;50uS&quot; is used.&nbsp; Rationale: in the high gyro high bandwidth mode, the ODR is 8000Hz; performing a read to clear the interrupt (required with the level held interrupt) is significantly more costly than doing nothing and returning from the ISR (possible in the pulse mode).&nbsp; While not tested, the overhead of checking the status register appears prohibitive.&nbsp; Therefore, the pulse mode is more suitable.</p><p>The ISR should react on the positive edge of the pulse. The initial approach was for the ISR checks that the pin is high and then call mpu_isr. An issue arises when other interrupts may delay the pin change interrrupt by more than 50uS (553 clk): the ISR would sample the pin level as zero and would not call the mpu_isr, essentially missing the MPU interrupt.</p><p>The alternative is to trigger mpu_isr on the falling edge of the pulse. As the pulse stays most of the time in the low state, this gives a higher likelihood for the ISR to be triggered when the pin state is low.</p><p>In a gyro high bandwidth mode, the interrupts are triggered at ODR=8KHz or every 125 uS.&nbsp; At 8KHz the pin would transition as follows: ...000I111-50uS111I00000-75uS00000I111-50uS111I000...&nbsp; I&lt;&nbsp; 125uS&nbsp; &gt;I</p><p>At ODR=1KHz interrupts are triggered every 125 uS. This is the 500Hz low-bandwidth mode At 1KHz the pin would transition as follows: ...000I111-50uS111I000000000-950uS000000000I111-50uS111I000...&nbsp; I&lt;&nbsp; 1000uS&nbsp; &gt;I The 950uS where interrupt pin is low provides enough time for the ISR to be called, check that the pin is low and call the mpu_isr.</p><p>Therefore, triggering the mpu_isr when the pin is low is recommended.</p><p>Possible issue: 000I111-50uS111I000000000-950uS000000000I111-50uS111I000...&nbsp; i&nbsp; i&nbsp; Pin change interrupt ...........I..C..M...R...I?</p><p>I indicates when the pin change ISR is called, possibly with significant delay.&nbsp; C indicates when the pin change ISR checks the pin state, which is now low: mpu_isr is called (M) and returns (R).&nbsp; The interrupt pin toggles from high to low during the pin change ISR.&nbsp; The AVR datasheet indicates about the pin change interrupt flag: &quot;The flag is cleared when the interrupt routine is executed.&quot;&nbsp; Interpreting this as when the interrupt is executed, the scenario above would call the mpu_isr a second time (indicated by the 2nd I) while in reality there is only one interrupt.</p><p>This can be addressed by reading the interrupt status register in the MPU routine at a cost of overhead.</p><p>Solution decided: clear PCIFR bit 2 to avoid superfluous calls to mpu_isr and check in mpu_isr for spurious motion interrupts.</p><p>In practice the firmware only handles up to ODR=500Hz (500Hz LBW) without data loss.</p><div class="CHeading">Todo</div><table class="CDefinitionList"><tr><td class="CDLEntry">V</td><td class="CDLDefinition"><p>Objective: this is the main file doing background acquisition of all the sensor data into in-memory structures</p></td></tr><tr><td class="CDLEntry">V</td><td class="CDLDefinition"><p>Only user-facing function to setup mode is mpu_config_motionmode(xxx) - new function &quot;enableall&quot; which enables communication with magnetometer; only used when setting up the magnetometer</p></td></tr><tr><td class="CDLEntry">V</td><td class="CDLDefinition"><p>quaternion here - Calibration using only FIFO</p></td></tr></table><div class="CHeading">Todo</div><p>V ensure direct register rw possible if interrupt-driven transfer: wait for interrupt transfer V move interrupt handling in mpu.c V move buffer handling in interrupt.c V add calibration V read magnetic calibration on init V move modes from main to mpu.c V #defines for the modes, instead of numbers V Clarify _mpu_agt_ongoing and _spiusart0_ongoing - rationalise/merge mpu.c &amp; motionconfig.c - document sample_mode - rename sample_mode - consider struct instead of individual arrays - faster transfer - move formatting for packet / strings to here?&nbsp; V benchmark - rename MOTIONCONFIG_NUM - Convert temperature to degrees - Longer calibration period</p></div>
</div>

<a name="Functions"></a><a name="Topic135"></a><div class="CTopic TGroup LC">
 <div class="CTitle">Functions</div>
</div>

<a name="mpu_clearstat"></a><a name="Topic292"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_clearstat</div>
 <div id="NDPrototype292" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_clearstat(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Clear the MPU acquisition statistics.</p><div class="CHeading">Returns</div><p>-</p></div>
</div>

<a name="mpu_getstat"></a><a name="Topic293"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_getstat</div>
 <div id="NDPrototype293" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_getstat(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">cnt_int,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">cnt_sample_tot,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">cnt_sample_succcess,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">cnt_sample_errbusy,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">long</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">cnt_sample_errfull</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Get the MPU acquisition statistics.</p><p>All parameters are pointer to a variable holding the return values.&nbsp; If the pointer is null, the corresponding parameter is not returned.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">cnt_int<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span>*</div></td><td class="CDLDefinition"><p>Number of MPU ISR calls</p></td></tr><tr><td class="CDLEntry">cnt_sample_tot<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span>*</div></td><td class="CDLDefinition"><p>Number of MPU samples so far, regardless of successfull or not</p></td></tr><tr><td class="CDLEntry">cnt_sample_succcess<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span>*</div></td><td class="CDLDefinition"><p>Number of successful MPU samples acquired</p></td></tr><tr><td class="CDLEntry">cnt_sample_errbusy<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span>*</div></td><td class="CDLDefinition"><p>Number of unsuccessful MPU sample acquisition due to the MPU interface being busy</p></td></tr><tr><td class="CDLEntry">cnt_sample_errfull<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">long</span>*</div></td><td class="CDLDefinition"><p>Number of unsuccessful MPU samples acquisition due to the MPU sample buffer being full</p></td></tr></table><div class="CHeading">Returns</div><p>-</p></div>
</div>

<a name="mpu_clearbuffer"></a><a name="Topic294"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_clearbuffer</div>
 <div id="NDPrototype294" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_clearbuffer(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Clears all sensor data held in the MPU buffers.</p><div class="CHeading">Parameters</div><p>-</p><div class="CHeading">Returns</div><p>-</p></div>
</div>

<a name="mpu_data_isfull"></a><a name="Topic136"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_data_isfull</div>
 <div id="NDPrototype136" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> mpu_data_isfull(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Returns 1 if the buffer is full, 0 otherwise.</p></div>
</div>

<a name="mpu_data_level"></a><a name="Topic244"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_data_level</div>
 <div id="NDPrototype244" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> mpu_data_level(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Returns how many samples are in the buffer, when automatic read is active.</p></div>
</div>

<a name="mpu_data_getnext_raw"></a><a name="Topic245"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_data_getnext_raw</div>
 <div id="NDPrototype245" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> mpu_data_getnext_raw(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">MPUMOTIONDATA&nbsp;</td><td class="PNamePrefix">&amp;</td><td class="PName last">data</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Returns the next data in the buffer, when automatic read is active and data is available.&nbsp; This function returns raw reads, without applying the calibration to take into account the accelerometer and gyroscope scale.</p><p>This function removes the data from the automatic read buffer and the next call to this function will return the next available data.</p><p>If no data is available, the function returns an error.</p><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error (no data available in the buffer)</p></td></tr></table></div>
</div>

<a name="mpu_data_getnext"></a><a name="Topic295"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_data_getnext</div>
 <div id="NDPrototype295" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> mpu_data_getnext(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">MPUMOTIONDATA&nbsp;</td><td class="PNamePrefix">&amp;</td><td class="PName last">data,</td></tr><tr><td class="PType first">MPUMOTIONGEOMETRY&nbsp;</td><td class="PNamePrefix">&amp;</td><td class="PName last">geometry</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Returns the next raw and geometry data, when automatic read is active and data is available.&nbsp; This function returns the raw reads and also computes the geometry (e.g. quaternions) from the raw data.</p><p>This function removes the data from the automatic read buffer and the next call to this function will return the next available data.</p><p>If no data is available, the function returns an error.</p><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Success</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error (no data available in the buffer)</p></td></tr></table></div>
</div>

<a name="_mpu_data_rdnext"></a><a name="Topic246"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_mpu_data_rdnext</div>
 <div id="NDPrototype246" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> _mpu_data_rdnext(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Advances the read pointer to access the next sample in the data buffer at index mpu_data_rdptr.&nbsp; Do not call if the buffer is empty.</p></div>
</div>

<a name="mpu_init"></a><a name="Topic296"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_init</div>
 <div id="NDPrototype296" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_init(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Initialise the MPU, the interrupt driven read, the magnetometer shadowing and puts the MPU and magnetometer in off mode.</p><p>Loads the non-volatile parameters from EEPROM which are: - magnetic correction mode and user magnetic correction coefficient - sensitivity of the accelerometer - sensitivity of the gyroscope</p></div>
</div>

<a name="mpu_mode_accgyro"></a><a name="Topic140"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_mode_accgyro</div>
 <div id="NDPrototype140" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_mode_accgyro(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">gdlpe,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">gdlpoffhbw,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">gdlpbw,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">adlpe,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">adlpbw,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">divider</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Set the MPU9250 in normal gyroscope and accelerometer mode - Gyroscope: on - Temperature: on - Accelerometer: on - clock: PLL</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">gdlpe<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>1 to enable gyroscope DLP.&nbsp; if enabled, gdlpbw specifies the bandwidth.</p></td></tr><tr><td class="CDLEntry">gdlpoffhbw<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>when DLP off, 1 to set high bandwidth (8800Hz) or 0 to set low bandwidth (3600Hz)</p></td></tr><tr><td class="CDLEntry">gdlpbw<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>when DLP on, set the DLP low pass filter.&nbsp; Possible values: MPU_GYR_LPF_250, 184, 92, 41, 20, 10, 5, 3600</p></td></tr><tr><td class="CDLEntry">adlpe<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>1 to enable the accelerometer DLP</p></td></tr><tr><td class="CDLEntry">adlpbw<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>bandwidth of the accelerometer DLP filter (MPU_ACC_LPF_460... MPU_ACC_LPF_5)</p></td></tr><tr><td class="CDLEntry">divider<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>divide the output of the DLP filter block by 1/(1+divider)</p></td></tr></table><p>The output data rate is as follows: 32KHz when gdlpe=0 8KHz when gdlpe=1 and gdlpbw=MPU_GYR_LPF_250 or MPU_GYR_LPF_3600 1KHz/(1+divider) when gdlp=1 and gdlpbw&lt;=MPU_GYR_LPF_184&lt;=MPU_GYR_LPF_5</p></div>
</div>

<a name="mpu_mode_off"></a><a name="Topic141"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_mode_off</div>
 <div id="NDPrototype141" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_mode_off(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Turns of as many things to lower power consumtion.&nbsp; - Gyroscope: off - Temperature: off - Accelerometer: off - Magnetometer off</p><p>This function can be called anytime.&nbsp; First, the communication with the magnetometer is shortly enabled (by activating the motion processor) in order to turn it off. Then the accelerometer, gyroscope and temperature sensors are turned off.</p></div>
</div>

<a name="mpu_fifoenable"></a><a name="Topic142"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_fifoenable</div>
 <div id="NDPrototype142" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_fifoenable(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">flags,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">en,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">reset</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Sets the FIFO flags (register FIFO Enable=35d), sets the FIFO enable bit (register User Control=106d) and sets the FIFO reset bit (register User Control=106d).</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">flags<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>FIFO enable flags (reg 35d). This bitmask is composed of the following bits:</p><p>TEMP GX GY GZ ACC SLV2 SLV1 SLV0</p></td></tr><tr><td class="CDLEntry">en<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>1 to enable the FIFO (reg 106d)</p></td></tr><tr><td class="CDLEntry">rst</td><td class="CDLDefinition"><p>1 to reset the FIFO (reg 106d)</p></td></tr></table></div>
</div>

<a name="mpu_setgyrobias"></a><a name="Topic143"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_setgyrobias</div>
 <div id="NDPrototype143" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_setgyrobias(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first"><span class="SHKeyword">short</span>&nbsp;</td><td class="PName last">bgx,</td></tr><tr><td class="PType first"><span class="SHKeyword">short</span>&nbsp;</td><td class="PName last">bgy,</td></tr><tr><td class="PType first"><span class="SHKeyword">short</span>&nbsp;</td><td class="PName last">bgz</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Sets the gyro bias registers</p></div>
</div>

<a name="mpu_setgyroscale"></a><a name="Topic297"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_setgyroscale</div>
 <div id="NDPrototype297" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_setgyroscale(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">scale</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Sets the gyro scale.</p><p>If the MPU is off it is turned on and then back off to get the parameter.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">scale<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>One of MPU_GYR_SCALE_250, MPU_GYR_SCALE_500, MPU_GYR_SCALE_1000 or MPU_GYR_SCALE_2000</p></td></tr></table></div>
</div>

<a name="mpu_getgyroscale"></a><a name="Topic298"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_getgyroscale</div>
 <div id="NDPrototype298" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> mpu_getgyroscale(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Sets the gyro scale.</p><p>If the MPU is off it is turned on and then back off to get the parameter.</p><div class="CHeading">Returns</div><p>One of MPU_GYR_SCALE_250, MPU_GYR_SCALE_500, MPU_GYR_SCALE_1000 or MPU_GYR_SCALE_2000</p></div>
</div>

<a name="mpu_setaccscale"></a><a name="Topic299"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_setaccscale</div>
 <div id="NDPrototype299" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_setaccscale(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">scale</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Sets the accelerometer scale.</p><p>If the MPU is off it is turned on and then back off to set the parameter.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">scale<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>One of MPU_ACC_SCALE_2, MPU_ACC_SCALE_4, MPU_ACC_SCALE_8, MPU_ACC_SCALE_16</p></td></tr></table></div>
</div>

<a name="mpu_getaccscale"></a><a name="Topic300"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_getaccscale</div>
 <div id="NDPrototype300" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> mpu_getaccscale(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Gets the acceleromter scale.</p><p>If the MPU is off it is turned on and then back off to get the parameter.</p><div class="CHeading">Returns</div><p>One of MPU_ACC_SCALE_2, MPU_ACC_SCALE_4, MPU_ACC_SCALE_8, MPU_ACC_SCALE_16</p></div>
</div>

<a name="mpu_setandstoreaccscale"></a><a name="Topic301"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_setandstoreaccscale</div>
 <div id="NDPrototype301" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_setandstoreaccscale(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">scale</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Sets the accelerometer scale and store the parameter in non-volatile memory.</p><p>If the MPU is off it is turned on and then back off to set the parameter.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">scale<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>One of MPU_ACC_SCALE_2, MPU_ACC_SCALE_4, MPU_ACC_SCALE_8, MPU_ACC_SCALE_16</p></td></tr></table></div>
</div>

<a name="mpu_setandstoregyroscale"></a><a name="Topic302"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_setandstoregyroscale</div>
 <div class="CBody"><p>Sets the gyro scale and store the parameter in non-volatile memory.</p><p>If the MPU is off it is turned on and then back off to set the parameter.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">scale</td><td class="CDLDefinition"><p>One of MPU_ACC_SCALE_2, MPU_ACC_SCALE_4, MPU_ACC_SCALE_8, MPU_ACC_SCALE_16</p></td></tr></table></div>
</div>

<a name="mpu_getwhoami"></a><a name="Topic303"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_getwhoami</div>
 <div id="NDPrototype303" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> mpu_getwhoami(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Returns MPU WHOAMI register</p><div class="CHeading">Parameters</div><p>- Returns Who am I value, 0x71 for the MPU9250</p></div>
</div>

<a name="mpu_reset"></a><a name="Topic304"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_reset</div>
 <div id="NDPrototype304" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_reset(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Resets the MPU.</p><p>According to the datasheet, all the registers are reset to 0, except register 107 (PWR_MGMT_1) which is set to 1 (Auto select best available clock, PLL or internal oscillator) and register WHO_AM_I.</p><div class="CHeading">Parameters</div><p>- Returns: -</p></div>
</div>

<a name="mpu_setsrdiv"></a><a name="Topic145"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_setsrdiv</div>
 <div id="NDPrototype145" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_setsrdiv(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">div</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Set sample rate divider register (register 25d).&nbsp; Sample rate = internal sample rate / (div+1) Only effective when fchoice=11 (fchoice_b=00) and 0&lt;dlp_cfg&lt;7</p></div>
</div>

<a name="mpu_set_interrutenable"></a><a name="Topic146"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_set_interrutenable</div>
 <div id="NDPrototype146" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_set_interrutenable(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">wom,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">fifo,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">fsync,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">datardy</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Enable the interrupts of the MPU. The parameters take a binary value to activate the corresponding interrupt source (1) or deactivate it (0).</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">wom<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>wake on motion</p></td></tr><tr><td class="CDLEntry">fifo<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>FIFO overflow</p></td></tr><tr><td class="CDLEntry">fsync<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>fsync interrupt</p></td></tr><tr><td class="CDLEntry">datardy<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>new data acquired</p></td></tr></table></div>
</div>

<a name="mpu_temp_enable"></a><a name="Topic147"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_temp_enable</div>
 <div id="NDPrototype147" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_temp_enable(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">enable</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Toggles the PD_PTAT bit in PWR_MGMT_1; i.e. enables or disables the temperature conversion.&nbsp; Does not affect any other setting.</p></div>
</div>

<a name="_mpu_wakefromsleep"></a><a name="Topic148"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_mpu_wakefromsleep</div>
 <div id="NDPrototype148" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> _mpu_wakefromsleep(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>This function wakes up the MPU from sleep mode and waits until ready.&nbsp; This function modifies the clock selection and the CYCLE and PTAT bits.</p></div>
</div>

<a name="mpu_clksel"></a><a name="Topic305"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_clksel</div>
 <div id="NDPrototype305" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_clksel(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">clk</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Changes the clksel bits in PWR_MGMT_1. Does not affect any other setting.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">clk<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Value between 0 and 7 inclusive corresponding to the clock source.</p><p>0 Internal 20MHz oscillator</p><p>1 Auto selects the best available clock source (Gyro X) ? PLL if ready, else use the Internal oscillator.</p><p>2 Auto selects the best available clock source ? PLL if ready, else use the Internal oscillator</p><p>3 Auto selects the best available clock source ? PLL if ready, else use the Internal oscillator</p><p>4 Auto selects the best available clock source ? PLL if ready, else use the Internal oscillator</p><p>5 Auto selects the best available clock source ? PLL if ready, else use the Internal oscillator</p><p>6 Internal 20MHz oscillator</p><p>7 Stops the clock and keeps timing generator in reset</p></td></tr></table></div>
</div>

<a name="_mpu_defaultdlpon"></a><a name="Topic150"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_mpu_defaultdlpon</div>
 <div id="NDPrototype150" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> _mpu_defaultdlpon(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Enables the MPU in a default mode. Typically it: - activates the accelerometer and gyroscope at 500Hz with LPF at 184Hz - selects the PLL oscillator</p><p>This mode allows to communicate with the magnetometer via the internal I2C interface.</p><p>Note: do not use in user code.</p></div>
</div>

<a name="_mpu_acquirecalib"></a><a name="Topic306"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_mpu_acquirecalib</div>
 <div id="NDPrototype306" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> _mpu_acquirecalib(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">clearbias</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Acquires calibration data in the FIFO.</p><p>Assumes the acceleration and gyroscope sensitivity are 2G and 250dps and that the gyro bias registers are 0.</p></div>
</div>

<a name="mpu_mag_readreg"></a><a name="Topic151"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_mag_readreg</div>
 <div id="NDPrototype151" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> mpu_mag_readreg(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">reg</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Reads the content of a magnotemeter register.</p><p>This function blocks until the data is read or a timeout occurs.</p><p>In order for this function to work, the MPU I2C interface must be active (mpu_mag_interfaceenable) and the MPU must be configured to sample acceleration or gyroscope data (not in low power mode).&nbsp; If not, the I2C interface is not active and the function will hang.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">reg<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Magnetometer register to read Returns: register</p></td></tr></table></div>
</div>

<a name="mpu_mag_writereg"></a><a name="Topic152"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_mag_writereg</div>
 <div id="NDPrototype152" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_mag_writereg(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">reg,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">val</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Writes the content of a magnotemeter register.</p><p>This function blocks until the data is written or a timeout occurs.</p><p>In order for this function to work, the MPU I2C interface must be active (mpu_mag_interfaceenable) and the MPU must be configured to sample acceleration or gyroscope data (not in low power mode).&nbsp; If not, the I2C interface is not active and the function will hang.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">reg<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Magnetometer register to write to</p></td></tr><tr><td class="CDLEntry">val<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Value to write in register</p></td></tr></table></div>
</div>

<a name="_mpu_mag_interfaceenable"></a><a name="Topic153"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_mpu_mag_interfaceenable</div>
 <div id="NDPrototype153" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> _mpu_mag_interfaceenable(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">en</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Enables the I2C communication interface between the magnetometer and the I2C master within the MPU.</p><p>In addition the MPU must be configured to sample acceleration or gyroscope data (not in low power mode).</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">en<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Enable (1) or disable (0) the interface</p></td></tr></table></div>
</div>

<a name="_mpu_mag_mode"></a><a name="Topic248"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_mpu_mag_mode</div>
 <div id="NDPrototype248" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> _mpu_mag_mode(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">mode,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">magdiv</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Enables or disable the conversion of the magnetometer sensors and.&nbsp; enables the shadowing of the magnetometer registers.</p><p>This function must only be called if the communication interface is enabled (mpu_mag_interfaceenable) and if the motion processor is active.&nbsp; Otherwise, timeout occur.</p><p>Note: do not use in user code.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">en</td><td class="CDLDefinition"><p>0: sleep mode. 1: 8Hz conversion. 2: 100Hz conversion.</p></td></tr><tr><td class="CDLEntry">magdiv<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Shadowing frequency divider; shadows register at ODR/(1+magdiv)</p></td></tr></table></div>
</div>

<a name="_mpu_mag_regshadow"></a><a name="Topic249"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_mpu_mag_regshadow</div>
 <div id="NDPrototype249" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> _mpu_mag_regshadow(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">enable,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">dly,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">regstart,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">numreg</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Setups the MPU to shadow the registers for the magnetometer into the MPU external sensor memory (reg 73d to 96d).</p><p>In order for this function to work, the MPU I2C interface must be active (mpu_mag_interfaceenable) and the MPU must be configured to sample acceleration or gyroscope data (not in low power mode).</p><p>In this mode, the MPU reads at periodic interval the magnetometer using the on-chip I2C interface. This allows the application to transparently read the magnetometer data using the mpu_readreg function, instead of the mpu_mag_readreg function.</p><p>The magnetometer must be configured separately for continuous conversion mode.</p><p>This only works when the MPU is not in low-power acceleration mode.</p><p><b>Magnetometer read rate</b></p><p>The magnetometer is read at the output data rate ODR/(1+dly), where dly is configurable. This is independent of the magnetometer ADC which is 8Hz or 100 Hz.</p><p>When the MPU is in some modes with high internal ODR (e.g. 8KHz with the gyro bandwidth is 250Hz) then the dly parameter should be set to higher values, otherwise the internal I2C interface to the magnetometer will block the acquisition of the gyro and acceleration data, leading to an effective sample rate lower than desired.</p><p>Note that the ODR is the sample rate (1KHz) divided by the acc/gyro sample rate divider (except in the gyro 250BW mode, where the ODR is 8KHz).</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">enable<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Enable (1) or disable (0) register shadowing</p></td></tr><tr><td class="CDLEntry">dly<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Read magnetometer at frequency ODR/(1+dly). dly e [0;31]</p></td></tr><tr><td class="CDLEntry">regstart<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>First magnetometer register to mirror</p></td></tr><tr><td class="CDLEntry">numreg<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>Number of magnetometer registers to mirror. numreg e [0;15] Returns: register</p></td></tr></table></div>
</div>

<a name="_mpu_mag_readasa"></a><a name="Topic156"></a><div class="CTopic TFunction LC">
 <div class="CTitle">_mpu_mag_readasa</div>
 <div id="NDPrototype156" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> _mpu_mag_readasa(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Read the magnetometer axis sensitivity adjustment value.&nbsp; Assumes MPU is in a mode allowing communication with the magnetometer.</p></div>
</div>

<a name="mpu_mag_correct1"></a><a name="Topic307"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_mag_correct1</div>
 <div id="NDPrototype307" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_mag_correct1(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">signed</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td></td><td class="PName last">mx,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">signed</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td></td><td class="PName last">my,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">signed</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td></td><td class="PName last">mz,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">volatile signed</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">mx2,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">volatile signed</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">my2,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">volatile signed</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">mz2</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Magnetic correction using factory parameters in fuse rom.</p><p>(ASA-128)x0.5 The correction is: Hadj = H x (--------------- + 1) 128</p><p>With ASA=128 the output is equal to the input.&nbsp; Values of ASA higher than 128 imply |Hadj|&gt;|H| (sign is preserved).&nbsp; Values of ASA lower than 128 imply |Hadj|&lt;|H| (sign in preserved).</p></div>
</div>

<a name="mpu_mag_correct2"></a><a name="Topic308"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_mag_correct2</div>
 <div id="NDPrototype308" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_mag_correct2(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">signed</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td></td><td class="PName last">mx,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">signed</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td></td><td class="PName last">my,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">signed</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td></td><td class="PName last">mz,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">signed</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">mx2,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">signed</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">my2,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">signed</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">mz2</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Magnetic correction using bias/sensitivity parameters found during calibration.</p><p>The sensitivity is a N.7 fixed point number.</p><p>Code size is smallest with /127, and &gt;&gt;7 is smaller than /127: /256 123250 /128 123236 /64 123248 /32 123260 /16 123248</p><p>&gt;&gt;8 123196 &gt;&gt;7 123192 &gt;&gt;6 123216</p></div>
</div>

<a name="mpu_mag_calibrate"></a><a name="Topic309"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_mag_calibrate</div>
 <div id="NDPrototype309" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_mag_calibrate(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Find the magnetometer calibration coefficients.</p><p>Finds a bias term to add to the magnetic data to ensure zero average.&nbsp; Finds a sensitivity term to multiply the zero-average magnetic data to span the range [-128,128] The sensitivity is a N.7 fixed-point number to multiply the integer magnetic field.</p><p>The earth magnetic field is up to ~0.65 Gauss=65 uT. The sensitivity of the AK8963 is .15uT/LSB.&nbsp; Hence the maximum readout is: 65uT/.15uT=433LSB.&nbsp; Therefore assume readout &lt; 450 for earth magnetic field.</p><p>The maximum value of sens is 128*128=16384.</p><div class="CHeading">Parameters</div><p>- Returns: Stores calibration coefficients in _mpu_mag_sens</p></div>
</div>

<a name="mpu_printreg"></a><a name="Topic157"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_printreg</div>
 <div id="NDPrototype157" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_printreg(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">FILE&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">file</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Prints the 128 registers from the MPU9250</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">file<div class="CDLParameterType">FILE*</div></td><td class="CDLDefinition"><p>Output stream</p></td></tr></table></div>
</div>

<a name="mpu_printreg(2)"></a><a name="Topic158"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_printreg</div>
 <div class="CBody"><p>Prints the 128 registers from the MPU9250</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">file</td><td class="CDLDefinition"><p>Output stream</p></td></tr></table></div>
</div>

<a name="mpu_printfifo"></a><a name="Topic159"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_printfifo</div>
 <div id="NDPrototype159" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_printfifo(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">FILE&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">file</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Prints the content of the FIFO</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">file<div class="CDLParameterType">FILE*</div></td><td class="CDLDefinition"><p>Output stream</p></td></tr></table></div>
</div>

<a name="mpu_mag_printreg"></a><a name="Topic160"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_mag_printreg</div>
 <div id="NDPrototype160" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_mag_printreg(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">FILE&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">file</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Prints the registers from the magnetometer.</p><p>The MPU I2C interface must be active (mpu_mag_interfaceenable) and the MPU must be configured to sample acceleration or gyroscope data (not in low power mode).</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">file<div class="CDLParameterType">FILE*</div></td><td class="CDLDefinition"><p>Output stream</p></td></tr></table></div>
</div>

<a name="mpu_printstat"></a><a name="Topic161"></a><div class="CTopic TFunction LC">
 <div class="CTitle">mpu_printstat</div>
 <div id="NDPrototype161" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_printstat(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">FILE&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">file</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Prints interrupt-driven (automatic mode) data acquisition statistics.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">file<div class="CDLParameterType">FILE*</div></td><td class="CDLDefinition"><p>Output stream</p></td></tr></table></div>
</div>

<a name="mpu_kill"></a><a name="Topic310"></a><div class="CTopic TFunction LC last">
 <div class="CTitle">mpu_kill</div>
 <div id="NDPrototype310" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> mpu_kill(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">bitmap</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Kills (i.e. sets to null) the sensors specified by the provided bitmap.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">bitmap<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>3-bit bitmap indicating whether to null acc|gyr|mag (mag is LSB).</p></td></tr></table><div class="CHeading">Returns</div><p>-</p></div>
</div>

</body></html>