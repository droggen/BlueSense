<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>adc.c</title><link rel="stylesheet" type="text/css" href="../../styles/main.css"><script type="text/javascript" src="../../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.0 (Development Release 08-22-2015) -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->

<body onload="NDLoader.OnLoad('Content');" class="NDPage NDContentPage">

<a name="ADC"></a><a name="Topic72"></a><div class="CTopic TFile LC first">
 <div class="CTitle">ADC</div>
 <div class="CBody"><p>ADC conversion functions.</p><p>The key functions are:</p><ul><li><p>ADCSetAutoPowerOff:			Sets whether the ADC should automatically be powered off after a conversion</p></li><li><p>ADCSetPrescaler:				Sets the prescaler for the ADC conversions</p></li><li><p>ADCRead:						Blocking single-channel ADC conversion</p></li><li><p>ADCReadPoll:					Blocking single-channel ADC conversion using polling</p></li><li><p>ADCReadMulti: 				Blocking multiple channel ADC conversions</p></li><li><p>ADCReadMultiCallback:			Non-blocking multiple channel ADC conversions with results provided to a user callback</p></li><li><p>ADCReadMultiCallbackBuffer:	Non-blocking multiple channel ADC conversions with results provided to a user callback via a user-provided buffer</p></li><li><p>ADCReadDoubleBuffered:		Blocking multiple channel ADC conversions with double buffering.</p></li><li><p>ADCWait:						Busy wait until an ongoing conversion is completed.</p></li><li><p>ADCIsRunning:					Indicates whether a conversion is ongoing</p></li></ul><p>Callback functions must be of type 'void cb(volatile unsigned short *)'. The callbacks are passed a pointer to a buffer containing the conversion results.&nbsp; This buffer is either an internal buffer of this library when using ADCReadMultiCallback or the user supplied buffer when using ADCReadMultiCallbackBuffer.</p><p><b>Usage in interrupts</b></p><p>The non-blocking functions are suitable for use in interrupts: ADCReadMultiCallback, ADCReadMultiCallbackBuffer and ADCIsRunning.</p><p>The blocking functions can also be used in the interrupts, however as they block until the conversion is done they will prevent the system from processing other tasks.</p><p><b>Notes</b> The behaviour is undefined when mixing ADCReadPoll and the other conversion functions. ADCReadPoll does not use a lock to check whether another conversion is in progress. It is suitable if only a single thread performs conversions.</p><p><b>Internals</b></p><p>Internally, all the converstions are building upon ADCReadMultiCallbackBuffer and are realised using interrupts, except ADCReadPoll.</p><p>The variable __adc_convtype is the state of the conversion logic:</p><table class="CDefinitionList"><tr><td class="CDLEntry">__adc_convtype=_ADC_CONVERSION_IDLE</td><td class="CDLDefinition"><p>No ongoing conversion (ADC is free)</p></td></tr><tr><td class="CDLEntry">__adc_convtype=_ADC_CONVERSION_ONGOING</td><td class="CDLDefinition"><p>Ongoing conversion (ADC is performing a conversion)</p></td></tr></table></div>
</div>

<a name="Functions"></a><a name="Topic73"></a><div class="CTopic TGroup LC">
 <div class="CTitle">Functions</div>
</div>

<a name="ADCSetAutoPowerOff"></a><a name="Topic74"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ADCSetAutoPowerOff</div>
 <div id="NDPrototype74" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> ADCSetAutoPowerOff(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">autopoweroff</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Sets whether the ADC should automatically be powered off after a conversion.</p><p>The first conversion after a power-off takes 25 ADC cycles, whereas subsequent conversions take 13 cycles.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">autopoweroff<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>0 to disable automatic power-off, 1 otherwise.</p></td></tr></table></div>
</div>

<a name="ADCSetPrescaler"></a><a name="Topic75"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ADCSetPrescaler</div>
 <div id="NDPrototype75" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> ADCSetPrescaler(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">prescaler</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Sets the prescaler for the ADC conversions.</p><p>This prescaler is used by all conversions. Use the macros ADCCONV_PRESCALER_xx to specify the prescaler.</p><p>The AVR documentation recommends to use an ADC clock between 50KHz and 200KHz to achieve the maximum resolution.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">prescaler<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>The prescaler value</p></td></tr></table><p>The following prescalers are available:</p><ul><li><p>ADCCONV_PRESCALER_128</p></li><li><p>ADCCONV_PRESCALER_64</p></li><li><p>ADCCONV_PRESCALER_32</p></li><li><p>ADCCONV_PRESCALER_16</p></li><li><p>ADCCONV_PRESCALER_8</p></li><li><p>ADCCONV_PRESCALER_4</p></li><li><p>ADCCONV_PRESCALER_2</p></li></ul></div>
</div>

<a name="ADCRead"></a><a name="Topic76"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ADCRead</div>
 <div id="NDPrototype76" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">short</span> ADCRead(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">channel,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">intvref</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Blocking single-channel ADC conversion.</p><p>Triggers a read of an ADC channel and returns after the conversion is completed.&nbsp; If an ongoing conversion is in progress, waits for it to complete before starting the new conversion.</p><p>This is not suitable for use in interrupts.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">channel<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>channel to convert: 0 to 7</p></td></tr><tr><td class="CDLEntry">intvref<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>1: 2.56V internal voltage reference; 0: AVCC voltage reference Note: intvref is currently not used</p></td></tr></table><div class="CHeading">Returns</div><p>Conversion result</p></div>
</div>

<a name="ADCReadPoll"></a><a name="Topic77"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ADCReadPoll</div>
 <div id="NDPrototype77" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">short</span> ADCReadPoll(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">channel</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Blocking single-channel ADC conversion using polling.</p><p>Triggers a read of an ADC channel and returns after the conversion is completed.</p><p>This function uses polling to wait for the conversion to complete and return the conversion result.</p><p>This function does not check if there is an ongoing conversion and therefore it should not be mixed with the other conversion functions provided by this library.</p><p>This function can be used in interrupts but care must be taken as it blocks until the conversion is completed.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">channel<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>channel to convert: 0 to 7</p></td></tr></table><div class="CHeading">Returns</div><p>Conversion result</p></div>
</div>

<a name="ADCReadMultiCallback"></a><a name="Topic78"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ADCReadMultiCallback</div>
 <div id="NDPrototype78" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> ADCReadMultiCallback(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">channels,</td></tr><tr><td class="first"></td><td class="PType">ADC_CALLBACK&nbsp;</td><td class="PName last">callback</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Non-blocking multiple channel ADC conversions with results provided to a user callback.</p><p>Starts the conversion of multiple ADC channels, calls a callback once completed with a pointer to a buffer holding the results.&nbsp; The data in this buffer must be consumed by the callback, as subsequent calls to this library may change the buffer content.</p><p>This function returns immediately with an error if there is already an ongoing conversion.</p><p>This function can be used in interrupts.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">channels<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>bitmask indicating which channel to convert. E.g. 0b01000011 converts ADC channel 0, 1 and 6.</p></td></tr><tr><td class="CDLEntry">callback<div class="CDLParameterType">ADC_CALLBACK</div></td><td class="CDLDefinition"><p>function to be called at the end of the conversion.&nbsp; If the callback is null then no callback is&nbsp; called and the user code must wait for the end of the conversion with ADCWait.</p></td></tr><tr><td class="CDLEntry">buffer</td><td class="CDLDefinition"><p>Buffer where the conversion results are stored</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Conversion started</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error: ongoing conversion</p></td></tr><tr><td class="CDLEntry">2</td><td class="CDLDefinition"><p>Error: no conversion requested</p></td></tr></table></div>
</div>

<a name="ADCReadMultiCallbackBuffer"></a><a name="Topic79"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ADCReadMultiCallbackBuffer</div>
 <div id="NDPrototype79" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> ADCReadMultiCallbackBuffer(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td></td><td class="PName last">channels,</td></tr><tr><td class="first"></td><td class="PType">ADC_CALLBACK&nbsp;</td><td></td><td class="PName last">callback,</td></tr><tr><td class="PModifierQualifier first"><span class="SHKeyword">volatile unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">short</span>&nbsp;</td><td class="PNamePrefix">*</td><td class="PName last">buffer</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Non-blocking multiple channel ADC conversions with results provided to a user callback via a user-provided buffer.</p><p>Starts the conversion of multiple ADC channels, calls a callback once completed with a pointer to a user-supplied buffer holding the results.</p><p>This function returns immediately with an error if there is already an ongoing conversion.</p><p>This function can be used in interrupts.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">channels<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>bitmask indicating which channel to convert. E.g. 0b01000011 converts ADC channel 0, 1 and 6.</p></td></tr><tr><td class="CDLEntry">callback<div class="CDLParameterType">ADC_CALLBACK</div></td><td class="CDLDefinition"><p>function to be called at the end of the conversion.&nbsp; If the callback is null then no callback is&nbsp; called and the user code must wait for the end of the conversion with ADCWait.</p></td></tr><tr><td class="CDLEntry">buffer<div class="CDLParameterType"><span class="SHKeyword">volatile unsigned</span> <span class="SHKeyword">short</span>*</div></td><td class="CDLDefinition"><p>Buffer where the conversion results are stored; this is the buffer which will be passed to the user callback upon completion.</p></td></tr></table><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>Conversion started</p></td></tr><tr><td class="CDLEntry">1</td><td class="CDLDefinition"><p>Error: ongoing conversion</p></td></tr><tr><td class="CDLEntry">2</td><td class="CDLDefinition"><p>Error: no conversion requested</p></td></tr></table></div>
</div>

<a name="ADCReadDoubleBuffered"></a><a name="Topic80"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ADCReadDoubleBuffered</div>
 <div id="NDPrototype80" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">short</span> *ADCReadDoubleBuffered(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PModifierQualifier first"><span class="SHKeyword">unsigned</span>&nbsp;</td><td class="PType"><span class="SHKeyword">char</span>&nbsp;</td><td class="PName last">channels</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Blocking multiple channel ADC conversions with double buffering.</p><p>This function returns the value of the previously launched ADC conversion, starts a new conversion, and returns immediately.&nbsp; This function is suitable when regular sampling is performed.&nbsp; Therefore the data returned by this function lags by one function call (1/samplerate, if regularly called), and allows to process incoming data while new data is sampled in the background.</p><p>If an ongoing conversion is in progress ADC this function blocks until that conversion is completed.</p><p>This is not suitable for use in interrupts.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">channels<div class="CDLParameterType"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span></div></td><td class="CDLDefinition"><p>bitmask indicating which channel to sample</p></td></tr></table><div class="CHeading">Return</div><p>Pointer to a 8-long buffer comprising the results</p></div>
</div>

<a name="ADCWait"></a><a name="Topic81"></a><div class="CTopic TFunction LC">
 <div class="CTitle">ADCWait</div>
 <div id="NDPrototype81" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> ADCWait(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Busy wait until an ongoing conversion is completed.</p></div>
</div>

<a name="ADCIsRunning"></a><a name="Topic82"></a><div class="CTopic TFunction LC last">
 <div class="CTitle">ADCIsRunning</div>
 <div id="NDPrototype82" class="NDPrototype WideForm CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">unsigned</span> <span class="SHKeyword">char</span> ADCIsRunning(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PName first last">void</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div>
 <div class="CBody"><p>Indicates whether a conversion is ongoing.</p><p>This function can be used in interrupts.</p><div class="CHeading">Returns</div><table class="CDefinitionList"><tr><td class="CDLEntry">0</td><td class="CDLDefinition"><p>No conversion is ongoing</p></td></tr><tr><td class="CDLEntry">nonzero</td><td class="CDLDefinition"><p>A conversion is ongoing</p></td></tr></table></div>
</div>

</body></html>